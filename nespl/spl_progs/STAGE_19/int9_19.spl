[PROCESS_TABLE + [SYSTEM_STATUS_TABLE + 1]*16 + 9] = 9;		//exec sys call no


alias userSP R1;
userSP = SP;

PTBR = [PROCESS_TABLE + ( [SYSTEM_STATUS_TABLE + 1] * 16) + 14];

[PROCESS_TABLE + ( [SYSTEM_STATUS_TABLE + 1] * 16) + 13] = SP;				//Save the current value of User SP into the corresponding Process Table entry.

SP = [PROCESS_TABLE + ([SYSTEM_STATUS_TABLE + 1] * 16) + 11] * 512 - 1;			// Setting SP to UArea Page number * 512 - 1

alias offset R2;
alias filename R3;

				//userSP - 4 is the location of the argument 
offset = (userSP - 4) % 512;
filename = [[PTBR + 2 * ((userSP - 4)/ 512)] * 512 + offset];


//search memory copy of inode table for file
alias i R2;
alias inodeFilename R5;
alias inodeIndex R4;

i=0;
inodeIndex = -1;
while( i < MAX_FILE_NUM ) do
	inodeFilename = [INODE_TABLE + (i * 16) + 1];	//file name in inode table
	if ( inodeFilename == filename ) then
		inodeIndex = i;
		if ([INODE_TABLE + (i * 16)] != EXEC) then
			inodeIndex = -1;
		endif;
		break;
	endif;
	i = i + 1;
endwhile;


//if not present return or not in XEXE format to usermode
if (inodeIndex == -1) then
	[PROCESS_TABLE + ( [SYSTEM_STATUS_TABLE + 1] * 16) + 9] = 0;
	[[PTBR + 2*((userSP - 1)/512)] * 512 + ((userSP - 1)%512)] = -1;
	SP = [PROCESS_TABLE + ( [SYSTEM_STATUS_TABLE + 1] * 16) + 13];
	ireturn;
endif;


//exit process - deallocate pages and resources
multipush(R0, R1, R2, R3, R4);
R1=3;
R2 = [SYSTEM_STATUS_TABLE + 1];
call MOD_1;
multipop(R0, R1, R2, R3, R4);



alias userAreapgno R5;
userAreapgno = [PROCESS_TABLE + ([SYSTEM_STATUS_TABLE + 1]*16) + 11];
[MEMORY_FREE_LIST + userAreapgno] = 1;
[SYSTEM_STATUS_TABLE + 2] = [SYSTEM_STATUS_TABLE + 2] - 1;

SP = [PROCESS_TABLE + ([SYSTEM_STATUS_TABLE + 1]*16) + 11]*512 - 1;
[PROCESS_TABLE + ( [SYSTEM_STATUS_TABLE + 1] * 16) + 4] = RUNNING;			//update state
[PROCESS_TABLE + ( [SYSTEM_STATUS_TABLE + 1] * 16) + 7] = inodeIndex;			//store inode index value



//reclaim all pages for new process
//Library
[PTBR+0] = 63;
[PTBR+1] = "0100";
[PTBR+2] = 64;
[PTBR+3] = "0100";


//Heap - get freepage (invalidate heap pages and dont allocate)
[PTBR + 4] = -1;
[PTBR + 5] = "0000";

[PTBR + 6] = -1;
[PTBR + 7] = "0000";

//Stack - get free page
multipush(R0, R1, R2, R3, R4, R5);
R1 = 1;
call MOD_2;
[PTBR + 16] = R0;
[PTBR + 17] = "0110";
multipop(R0,R1,R2,R3,R4,R5);
multipush(R0, R1, R2, R3, R4, R5);
R1 = 1;
call MOD_2;
[PTBR + 18] = R0;
[PTBR + 19] = "0110";
multipop(R0,R1,R2,R3,R4,R5);



//code 
multipush(R0, R1, R2, R3, R4, R5);
R1 = 5;
R2 = [INODE_TABLE + (inodeIndex * 16) + 8];
R3 = [SYSTEM_STATUS_TABLE+1];
call MOD_2;
//print R0;
[PTBR + 8] = R0;
[PTBR + 9] = "0110";
multipop(R0,R1,R2,R3,R4,R5);

//print "here2";
[PTBR + 10] = -1;
[PTBR + 11] = "0000";
[PTBR + 12] = -1;
[PTBR + 13] = "0000";
[PTBR + 14] = -1;
[PTBR + 15] = "0000";
//initialize Disk Map Table
[DISK_MAP_TABLE + [SYSTEM_STATUS_TABLE + 1] *10 + 0] =-1;
[DISK_MAP_TABLE + [SYSTEM_STATUS_TABLE + 1] *10 + 1] =-1;
[DISK_MAP_TABLE + [SYSTEM_STATUS_TABLE + 1] *10 + 2] =-1;
[DISK_MAP_TABLE + [SYSTEM_STATUS_TABLE + 1] *10 + 3] =-1;
[DISK_MAP_TABLE + [SYSTEM_STATUS_TABLE + 1] *10 + 4] = [INODE_TABLE + (inodeIndex * 16) + 8 + 0];
[DISK_MAP_TABLE + [SYSTEM_STATUS_TABLE + 1] *10 + 5] = [INODE_TABLE + (inodeIndex * 16) + 8 + 1];
[DISK_MAP_TABLE + [SYSTEM_STATUS_TABLE + 1] *10 + 6] = [INODE_TABLE + (inodeIndex * 16) + 8 + 2];
[DISK_MAP_TABLE + [SYSTEM_STATUS_TABLE + 1] *10 + 7] = [INODE_TABLE + (inodeIndex * 16) + 8 + 3];
[DISK_MAP_TABLE + [SYSTEM_STATUS_TABLE + 1] *10 + 8] =-1;
[DISK_MAP_TABLE + [SYSTEM_STATUS_TABLE + 1] *10 + 9] =-1;


[[PTBR + 16] * 512] = [[PTBR + 8]*512 + 1];
SP = 8*512;

[PROCESS_TABLE + ([SYSTEM_STATUS_TABLE + 1] * 16) + 9]=0;
ireturn;
