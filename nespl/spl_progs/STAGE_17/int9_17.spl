[PROCESS_TABLE + [SYSTEM_STATUS_TABLE + 1]*16 + 9] = 9;


alias userSP R0;
userSP = SP;


[PROCESS_TABLE + ( [SYSTEM_STATUS_TABLE + 1] * 16) + 13] = SP;				//Save the current value of User SP into the corresponding Process Table entry.

SP = [PROCESS_TABLE + ([SYSTEM_STATUS_TABLE + 1] * 16) + 11] * 512 - 1;			// Setting SP to UArea Page number * 512 - 1

alias offset R1;
alias filename R2;

				//userSP - 4 is the location of the argument 
offset = (userSP - 4) % 512;
filename = [[PTBR + 2 * ((userSP - 4)/ 512)] * 512 + offset];				//get filename argument


alias i R1;
alias inodeFilename R3;
alias inodeIndex R4;

i=0;
inodeIndex = -1;
while( i < MAX_FILE_NUM ) do								//get inode table entry for filename
	inodeFilename = [INODE_TABLE + (i * 16) + 1];	//file name in inode table
	if ( inodeFilename == filename ) then
		inodeIndex = i;
		if ([INODE_TABLE + (i * 16)] != EXEC) then				//if it is in exec file
			inodeIndex = -1;
		endif;
		break;
	endif;
	i = i + 1;
endwhile;


if (inodeIndex == -1) then								//if filename doesnt exist then 
	[PROCESS_TABLE + ( [SYSTEM_STATUS_TABLE + 1] * 16) + 9] = 0;			//mode = user
	[[PTBR + 2*((userSP - 1)/512)] * 512 + ((userSP - 1)%512)] = -1;	
	SP = [PROCESS_TABLE + ( [SYSTEM_STATUS_TABLE + 1] * 16) + 13];			//set user stack
	ireturn;
endif;


multipush(R0, R1, R2, R3, R4);
R1=3;									//call exit process		
R2 = [SYSTEM_STATUS_TABLE + 1];
call MOD_1;
multipop(R0, R1, R2, R3, R4);



alias userAreapgno R5;
userAreapgno = [PROCESS_TABLE + ([SYSTEM_STATUS_TABLE + 1]*16) + 11];		//get user area page no
[MEMORY_FREE_LIST + userAreapgno] = 1;
[SYSTEM_STATUS_TABLE + 2] = [SYSTEM_STATUS_TABLE + 2] - 1;

SP = [PROCESS_TABLE + ([SYSTEM_STATUS_TABLE + 1]*16) + 11]*512 - 1;
[PROCESS_TABLE + ( [SYSTEM_STATUS_TABLE + 1] * 16) + 4] = RUNNING;
[PROCESS_TABLE + ( [SYSTEM_STATUS_TABLE + 1] * 16) + 7] = inodeIndex;

alias ptbr R6;
ptbr = [PROCESS_TABLE + ( [SYSTEM_STATUS_TABLE + 1] * 16) + 14];

//Library
[ptbr+0] = 63;
[ptbr+1] = "0100";
[ptbr+2] = 64;
[ptbr+3] = "0100";


//Heap
multipush(R0, R1, R2, R3, R4, R5);
R1 = 1;
call MOD_2;
[ptbr + 4] = R0;
[ptbr + 5] = "0110";
multipop(R0,R1,R2,R3,R4,R5);
multipush(R0, R1, R2, R3, R4, R5);
R1 = 1;
call MOD_2;
[ptbr + 6] = R0;
[ptbr + 7] = "0110";
multipop(R0,R1,R2,R3,R4,R5);


//Stack
multipush(R0, R1, R2, R3, R4, R5);
R1 = 1;
call MOD_2;
[ptbr + 16] = R0;
[ptbr + 17] = "0110";
multipop(R0,R1,R2,R3,R4,R5);
multipush(R0, R1, R2, R3, R4, R5);
R1 = 1;
call MOD_2;
[ptbr + 18] = R0;
[ptbr + 19] = "0110";
multipop(R0,R1,R2,R3,R4,R5);

alias j R2;
j=0;
while(j<4) do
	if([INODE_TABLE + (inodeIndex * 16) + 8 + j] != -1) then
		multipush(R1, R2, R3, R4, R5);
		R1 = 1;
		call MOD_2;
		[ptbr + j*2 + 8] = R0;
		[ptbr + j*2 + 9] = "0100";
		multipop(R1,R2,R3,R4,R5);
		loadi(R0, [INODE_TABLE + (inodeIndex * 16) + 8 + j]);
	else
		[ptbr + j*2 + 8] = -1;
		[ptbr + j*2 + 9] = "0000";
	endif;
	
	j = j + 1;
endwhile;

[[ptbr + 16] * 512] = [[ptbr + 8]*512 + 1];
SP = 8*512;

[PROCESS_TABLE + ([SYSTEM_STATUS_TABLE + 1] * 16) + 9]=0;
ireturn;
