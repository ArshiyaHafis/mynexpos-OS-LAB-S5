alias userSP R1;
alias sysCallNo R2;
alias pTable R3;

pTable = PROCESS_TABLE + [SYSTEM_STATUS_TABLE + 5*CORE + 1]*16;
[pTable + 13]= SP;
SP = [pTable + 11] * 512  - 1 ;
PTBR = [pTable + 14] ;

userSP = [pTable + 13];
sysCallNo = [[PTBR + 2*((userSP-5)/512)] * 512 + ((userSP-5)%512)] ;
[pTable + 9] = sysCallNo;

multipush(R1, R2, R3);
R1 = 1;
call MOD_8;
multipop(R1, R2, R3);

alias arg1 R4;
arg1  = [[PTBR + 2*((userSP-4)/512)] * 512 + ((userSP-4)%512)] ;
alias returnAddress R5;
returnAddress = [PTBR + 2*((userSP-1)/512)] * 512 + ((userSP-1)%512) ;

if(sysCallNo == 2) then 						//  Open
    alias fileName R4;
    alias pprTable R6;
    alias freeEntry R7;
    alias i R8;
    pprTable = [pTable + 11] * 512 + RESOURCE_TABLE_OFFSET;
    i = 0;
    freeEntry = -1;

    while(i < 8) do 
        if([pprTable + 2*i] == -1) then
            freeEntry = i;
            break;
        endif;
        i = i + 1;

    endwhile;

    if(freeEntry == -1) then					//ppr table is full
            [returnAddress] = -3;
            goto KERN_IRET;
    endif;

    multipush(R1,R2,R3,R4,R5,R6,R7);				//open function in file manager module
    R1 = OPEN;
    R2 = fileName;
    call FILE_MANAGER;
    multipop(R1,R2,R3,R4,R5,R6,R7);


    if(R0 == -1 || R0 == -2 || R0 == -3) then			//error codes
            [returnAddress] = R0;
            goto KERN_IRET;
    endif;

    [pprTable + 2*freeEntry] = FILE;				// set ppr Table with entries
    [pprTable + 2*freeEntry + 1] = R0;
    [returnAddress] = freeEntry;
    goto KERN_IRET;
endif;



if(sysCallNo == 6 || sysCallNo ==  3) then // seek or close
    alias fd R4;
    if(fd<0 || fd>7) then
        [returnAddress] = -1;
        goto KERN_IRET;
    endif;
	
    alias pprTableEntry R6;						//get per process resource entry
    pprTableEntry = [pTable + 11]  * 512  + RESOURCE_TABLE_OFFSET + 2*fd;
    if([pprTableEntry] == -1 || [pprTableEntry] != FILE) then
        [returnAddress] = -1;
        goto KERN_IRET;
    endif;

    alias oftTable R7;
    oftTable = OPEN_FILE_TABLE + [pprTableEntry + 1] * 4;
    
    if(sysCallNo == 6) then
       
        alias iIndex R8;
        alias iTable R9;
        iIndex = [oftTable];

        iTable =  INODE_TABLE + iIndex * 16 ;

        if([iTable+4] == 0) then
            if( [SYSTEM_STATUS_TABLE] != 1 || [iTable+3] != [SYSTEM_STATUS_TABLE]) then
                [returnAddress] = -3;
                goto KERN_IRET;
            endif;
        endif;

        multipush(R1,R2,R3,R4,R5,R6,R7,R8,R9);
        R1 = ACQUIRE_INODE;
        R2 = iIndex;
        R3 = [SYSTEM_STATUS_TABLE + 5*CORE + 1];
        call RESOURCE_MANAGER;
        multipop(R1,R2,R3,R4,R5,R6,R7, R8,R9);

        if(R0 == -1) then
            [returnAddress] = -1;
            goto KERN_IRET;
        endif;

        alias offset R10;
        offset = [([PTBR + 2* ((userSP - 3) / 512)] * 512) + ((userSP - 3) % 512)] ;
    
        alias fileSize R11;
        if(iIndex == INODE_ROOT) then
            fileSize = 480;
        else
            fileSize = [iTable + 2];
        endif;


        if([oftTable+2] + offset < 0 ) then 						//offset outside file then return -2
            multipush(R1,R2,R3,R4,R5,R6,R7,R8, R9,R10,R11);
            R1 = RELEASE_INODE;
            R2 = iIndex;
            R3 = [SYSTEM_STATUS_TABLE + 5*CORE + 1];
            call RESOURCE_MANAGER;
            multipop(R1,R2,R3,R4,R5,R6,R7,R8,R9,R10,R11);


            [returnAddress] = -2;
            goto KERN_IRET;

        endif;
        
        if(offset == 0) then
            [oftTable+2] = 0;

        else
            if([oftTable+2]+offset > fileSize) then					//points to outside the file then set lseek as file size
                [oftTable+2] = fileSize;

            else									//points to somewhere inside the file, then give current position
                [oftTable+2] = [oftTable+2] + offset;

            endif;
        endif;

        multipush(R1,R2,R3,R4,R5,R6,R7,R8,R9,R10,R11);
        R1 = RELEASE_INODE;
        R2 = iIndex;
        R3 = [SYSTEM_STATUS_TABLE + 5*CORE + 1];
        call RESOURCE_MANAGER;
        multipop(R1,R2,R3,R4,R5,R6,R7,R8,R9,R10,R11);
        [returnAddress] = 0;
        goto KERN_IRET;
    endif;

    if(sysCallNo == 3) then // Close
    
        multipush(R1,R2,R3,R4,R5,R6,R7,R8,R9,R10,R11);
        R1 = CLOSE;
        R2 = [pprTableEntry+1];
        call FILE_MANAGER;
        multipop(R1,R2,R3,R4,R5,R6,R7,R8,R9,R10,R11);

        [pprTableEntry] = -1;
        [pprTableEntry+1] = -1;
        [returnAddress] = 0;
        goto KERN_IRET;
    endif;
endif;

KERN_IRET :
	multipush(R1,R2,R3,R4,R5,R6,R7,R8,R9,R10);
	R1 = RELEASE_LOCK;
	R2 = KERN_LOCK;
	call ACCESS_CONTROL;
	multipop(R1,R2,R3,R4,R5,R6,R7,R8,R9,R10);

[pTable + 9] = 0;
SP = [pTable + 13];
ireturn;
