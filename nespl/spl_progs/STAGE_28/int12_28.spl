alias userSP R1;
alias sysCallNo R2;
alias pTable R3;
alias returnAddress R4;

pTable = PROCESS_TABLE + [SYSTEM_STATUS_TABLE + 5*CORE + 1]*16;
[pTable + 13]= SP;
SP = [pTable + 11] * 512  - 1 ;
PTBR = [pTable + 14] ;
userSP = [pTable + 13];
sysCallNo = [[PTBR + 2*((userSP-5)/512)] * 512 + ((userSP-5)%512)] ;
[pTable + 9] = sysCallNo;
returnAddress = [PTBR + 2*((userSP-1)/512)] * 512 + ((userSP-1)%512) ;

if(sysCallNo == 28) then 					// logout
    if([SYSTEM_STATUS_TABLE + 5*CORE + 1] != 2) then			//current process not shell
        [returnAddress] = -1;
        [pTable + 9] = 0;
        SP = [pTable + 13];
        ireturn;
    endif;



    multipush(R1,R2,R3,R4);					//kill all user processes
    R1 = ACQUIRE_KERN_LOCK;
    call ACCESS_CONTROL;
    
    R1 = KILL_ALL;
    R2 = [SYSTEM_STATUS_TABLE + 5*CORE + 1];
    call PROCESS_MANAGER;
    
    R1 = RELEASE_LOCK;
    R2 = KERN_LOCK;
    call ACCESS_CONTROL;
    
    multipop(R1,R2,R3,R4);


    [pTable + 4] = TERMINATED;					//state of shell process = Terminated
    alias ip R5;
    ip = [[[pTable+14] + 8]*512 + 1];
    [[[pTable+14] + 16]*512] = ip;	//point SP to top of code
    [pTable + 13] = 8*512;

    [PROCESS_TABLE +16*1+ 4] = READY;
    
    [SYSTEM_STATUS_TABLE] = 0;

    multipush(R1,R2,R3,R4); 
    call SCHEDULER;
    multipop(R1,R2,R3,R4); 
endif;


[pTable + 9] = 0;
SP = [pTable + 13];
ireturn;
