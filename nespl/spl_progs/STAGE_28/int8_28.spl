alias pTable R9;
pTable = PROCESS_TABLE + ([SYSTEM_STATUS_TABLE + 5*CORE + 1]*16);
[pTable + 9] = 8;
[pTable + 13] = SP;
SP = [pTable + 11] * 512  - 1 ;
PTBR = [pTable + 14];
PTLR = [pTable + 15];

multipush(R9);					//index of child process table
R1 = GET_PCB_ENTRY;
call PROCESS_MANAGER;
multipop(R9);


multipush(R9);
R1 = 1;
call MOD_8;
multipop(R9);


alias childPID R1;
alias childPTBR R2;
alias cpTable R3;

childPID = R0;
cpTable = PROCESS_TABLE + childPID*16;
childPTBR = [cpTable + 14];

if(childPID == -1)then
    [pTable + 9] = 0;
    alias userSP_MinusOne R1;
    userSP_MinusOne = [pTable + 13]-1;
    [[PTBR + 2*((userSP_MinusOne)/512)] * 512 + ((userSP_MinusOne)%512)] = -1;
    
    multipush(R4);
    R1 = RELEASE_LOCK;
    R2 = KERN_LOCK;
    call ACCESS_CONTROL;
    multipop(R4);
    
    SP = [pTable + 13];
    ireturn;
endif;

//allocating heap for parent if it does not have any
if ( [PTBR + 4] == -1 )then
    multipush(R0,R1,R2,R3,R4,R5,R6,R7,R8,R9);
    R1 = 1;
    call MOD_2;
    [PTBR + 4]  = R0;
    [PTBR + 5]  = "1110";

    R1 = 1;
    call MOD_2;
    [PTBR + 6]  = R0;
    [PTBR + 7]  = "1110";
    multipop(R0,R1,R2,R3,R4,R5,R6,R7,R8,R9);
endif;

// User Area Page of the child process
multipush(R1,R2,R3,R4);
R1 = GET_FREE_PAGE; 
call MEMORY_MANAGER; 
multipop(R1,R2,R3,R4);
[cpTable+ 11]=R0;



childPTBR = PAGE_TABLE_BASE + 20*childPID;


//allocating stack pages for child
multipush(R1,R2,R3,R4,R5,R6,R7,R8,R9);
R1 = 1;
call MEMORY_MANAGER;
multipop(R1,R2,R3,R4,R5,R6,R7,R8,R9);

[childPTBR + 16] = R0;
[childPTBR + 17] = "0110";

multipush(R1,R2,R3,R4,R5,R6,R7,R8,R9);
R1 = 1;
call MEMORY_MANAGER;
multipop(R1,R2,R3,R4,R5,R6,R7,R8,R9);

[childPTBR + 18] = R0;
[childPTBR + 19] = "0110";


//Copying UserID, Swap Flag, Inode Index, UASwapStatus, UPTR from Parent to Child
[cpTable + 3] = [pTable + 3]; 
[cpTable + 6] = [pTable + 6];
[cpTable + 7] = [pTable + 7];
[cpTable + 10] = [pTable + 10];
[cpTable + 13] = [pTable + 13];

//Setting MODE Flag, KPTR, TICK to 0 
[cpTable+ 2] = [SYSTEM_STATUS_TABLE + 5*CORE + 1];
[cpTable+ 0] = 0;
[cpTable+ 9] = 0;
[cpTable+ 12] = 0;
[cpTable+4] = CREATED ;

// Per-process resource table 

alias ppprTable R6;
alias cpprTable R7;
alias i R5;
alias offset R8;
i  = 0;
while(i<8) do 
    offset =  RESOURCE_TABLE_OFFSET+2*i;
    ppprTable = (([pTable + 11] ) * 512 ) + offset;
    cpprTable = (([cpTable + 11] ) * 512 ) + offset;
    [cpprTable] = [ppprTable];
    [cpprTable+1] = [ppprTable+1];
    if([ppprTable] == SEMAPHORE) then
        alias sTable R10;
        sTable = SEMAPHORE_TABLE + [ppprTable + 1] * 4;
        [sTable + 1] = [sTable + 1] + 1;
    endif;
    
    if([ppprTable] == FILE) then
        alias oftTable R10;
        oftTable = OPEN_FILE_TABLE + [ppprTable + 1] * 4;
        [oftTable + 1] = [oftTable + 1] + 1;
    endif;
    i = i + 1;
endwhile;


i=0; 
while(i<10) do
    [DISK_MAP_TABLE + childPID*10 +i] = [DISK_MAP_TABLE + [SYSTEM_STATUS_TABLE + 5*CORE + 1]*10 + i];
    i = i + 1;
endwhile;


//Page Table of Child Process
//Library
i=0;
while(i<8) do
    [childPTBR+i] = [PTBR+i];
    i = i + 1;
endwhile;

//Updating MEMORY_FREE_LIST of Lib Stack Heap
i = 0;
while (i<7)do
    [MEMORY_FREE_LIST + [PTBR + i] ] = [MEMORY_FREE_LIST + [PTBR + i] ] + 1;
    i = i + 2;
endwhile;


//MEMORY_FREE_LIST of Code Pages
i=8;
while(i<15) do
    [childPTBR + i] =  [PTBR + i];
    [childPTBR + i+1] =  [PTBR + i+1];

    if([PTBR + i]  != -1) then
        [MEMORY_FREE_LIST+ [PTBR + i]] =  [MEMORY_FREE_LIST+ [PTBR + i]] +1;
    endif;

    i = i+2;
endwhile;


//Copying Parent Stack to Child Stack 

alias j R7;

i = 16;

while( i < 19)do
        j=0;
        while( j < 512 )do
            [[childPTBR + i] * 512 + j ] = [[PTBR + i] * 512 + j ];
            j = j + 1;
        endwhile;
    i=i+2;
endwhile;





// Set Return value to ChildPID for Parent   
alias returnAddress R2;
returnAddress = ([PTBR + 2 * (([pTable + 13] - 1) / 512)] * 512) + (([pTable + 13] - 1) % 512);
[returnAddress] = childPID;

//Set Return value to 0 for Child  
returnAddress = ([PAGE_TABLE_BASE  + 20*childPID  + 2 * (([pTable + 13] - 1) / 512)] * 512) + (([pTable + 13] - 1) % 512);
[returnAddress] = 0;
[[PROCESS_TABLE + 16*childPID + 11] * 512 ] = BP;

multipush(R4);
R1 = RELEASE_LOCK;
R2 = KERN_LOCK;
call ACCESS_CONTROL;
multipop(R4);
    
[pTable+ 9] = 0;
SP = [pTable + 13];
ireturn;
