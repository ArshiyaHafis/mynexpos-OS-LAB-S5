alias pTable R1;
pTable = PROCESS_TABLE + ([SYSTEM_STATUS_TABLE + 5*CORE + 1]*16);
[pTable + 9] = 6;
[pTable + 13] = SP;
alias userSP R2;
userSP=SP;
SP = [pTable+ 11] * 512 - 1;
PTBR = [pTable+ 14];
alias fd R3;
alias returnAddress R4;

fd = [[PTBR + 2*((userSP-4)/512)] * 512 + ((userSP-4)%512)] ;
returnAddress = [PTBR + 2*((userSP-1)/512)] * 512 + ((userSP-1)%512) ;


multipush(R1,R2,R3,R4);
R1 = ACQUIRE_KERN_LOCK;
call ACCESS_CONTROL;
multipop(R1,R2,R3,R4);


if(fd == -2) then								//word to be written to terminal

    alias word R5;
    word = [[PTBR + 2 * ((userSP - 3) / 512)] * 512 + ((userSP - 3) % 512)];
    
    multipush(R0, R1, R2, R3, R4, R5);
    R1 = TERMINAL_WRITE;
    R2 = [SYSTEM_STATUS_TABLE + 5*CORE + 1]; 
    R3 = word;
    call MOD_4;
    multipop(R0, R1, R2, R3, R4, R5);
    
    [returnAddress] = -1;
    goto KERN_IRET;

   
else										//write to file
    if(fd<0 || fd>7) then							//invalid fd
        [returnAddress] = -1;
        goto KERN_IRET;
    endif;
    
    
    alias pprTable R5;
    pprTable = [pTable + 11]  * 512  + RESOURCE_TABLE_OFFSET + 2*fd;

    if([pprTable] == -1 || [pprTable] != FILE) then				//invalid resource table entry
        [returnAddress] = -1;
        goto KERN_IRET;
    endif;


    alias oftTable R6;								//index of oft
    alias iIndex R7;								//index of inode table
    alias iTable R8;
    alias userId R9;
    oftTable = OPEN_FILE_TABLE + [pprTable + 1] * 4;
    iIndex = [oftTable + 0];
    iTable = INODE_TABLE + iIndex * 16;						//inode table
    userId = [pTable+3];

    if([iTable+4] == EXCLUSIVE) then						
        if( userId != 1 || [iTable+3] != userId) then		  //if current user is not root and user is not owner of file and file is not editable
            [returnAddress] = -3;
        goto KERN_IRET;
            ireturn;
        endif;
    endif;


    multipush(R1,R2,R3,R4,R5,R6,R7,R8);		//ACQUIRE INODE FROM RESOURCE MANAGER
    R1 = 4;
    R2 = iIndex;
    R3 = [SYSTEM_STATUS_TABLE + 5*CORE + 1];
    call MOD_0;
    multipop(R1,R2,R3,R4,R5,R6,R7,R8);

    
    if(R0 == -1) then					//couldnt acquire inode
        [returnAddress] = -1;
        goto KERN_IRET;
    endif;



    alias logicalAddressOfMemoryBuffer R9;
    logicalAddressOfMemoryBuffer = [([PTBR + 2* ((userSP - 3) / 512)] * 512) + ((userSP - 3) % 512)] ;

     
    if([oftTable+2] == MAX_FILE_SIZE) then				//lseek is reached maximum file size - 2048
    
        multipush(R1,R2,R3,R4,R5,R6,R7,R8,R9,R10);      
        R1 = 5;
        R2 = iIndex;
        R3 = [SYSTEM_STATUS_TABLE + 5*CORE + 1];
        call MOD_0;
        multipop(R1,R2,R3,R4,R5,R6,R7,R8,R9, R10);

        [returnAddress] = -2;
        goto KERN_IRET;
    endif;



    if([oftTable+2]%512 == 0 && [iTable+2] ==[oftTable+2] ) then		//lseek at end of file
    
    
        multipush(R1,R2,R3,R4,R5,R6,R7,R8,R9,R10);				//new block allocated
        R1 = GET_FREE_BLOCK;
        call MEMORY_MANAGER;
        multipop(R1,R2,R3,R4,R5,R6,R7,R8,R9, R10);


        if( R0 == -1) then							//no block available do release inode
            multipush(R1,R2,R3,R4,R5,R6,R7,R8,R9, R10);
            R1 = 5;
            R2 = iIndex;
            R3 = [SYSTEM_STATUS_TABLE + 5*CORE + 1];
            call MOD_0;
            multipop(R1,R2,R3,R4,R5,R6,R7,R8,R9, R10);

            [returnAddress] = -2;
        	goto KERN_IRET;
        endif;
        [iTable + 8 + [oftTable+2]/512] = R0;

    endif;

    multipush(R1,R2,R3,R4,R5,R6,R7,R8, R9, R10);				//write word to file buffer
    R1 = BUFFERED_WRITE;
    R2 = [INODE_TABLE + iIndex*16 + 8 + [oftTable+2]/512];
    R3 = [oftTable+2]%512;
    R4 = logicalAddressOfMemoryBuffer;
    call FILE_MANAGER;
    multipop(R1,R2,R3,R4,R5,R6,R7,R8, R9, R10);



    if([oftTable+2] == [iTable+2]) then						//if lseek==filesize increment file size in itable and rootfile

        [iTable+2] = [iTable+2] + 1;
        [ROOT_FILE + iIndex*8+1] = [ROOT_FILE  + iIndex*8+1] + 1;

    endif;
    [oftTable+2] = [oftTable+2] + 1;						//increment lseek

	
	[returnAddress] = 0;
    multipush(R1,R2,R3,R4,R5,R6,R7,R8, R9, R10);				//release inode lock
    R1 = 5;
    R2 = iIndex;
    R3 = [SYSTEM_STATUS_TABLE + 5*CORE + 1];
    call MOD_0;
    multipop(R1,R2,R3,R4,R5,R6,R7,R8, R9, R10);
endif;

KERN_IRET :
	multipush(R1,R2,R3,R4,R5,R6,R7,R8,R9,R10);
	R1 = RELEASE_LOCK;
	R2 = KERN_LOCK;
	call ACCESS_CONTROL;
	multipop(R1,R2,R3,R4,R5,R6,R7,R8,R9,R10);

[pTable + 9] = 0;
SP = [pTable + 13];
ireturn;
