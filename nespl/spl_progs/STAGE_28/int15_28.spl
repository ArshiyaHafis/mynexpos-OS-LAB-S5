
alias userSP R1;
alias pTable R3;
pTable = PROCESS_TABLE + [SYSTEM_STATUS_TABLE + 5*CORE + 1]*16;
[pTable + 13]= SP;
SP = [pTable + 11] * 512  - 1 ;
PTBR = [pTable + 14] ;
userSP = [pTable + 13];
[pTable + 9] = 21;

if ([pTable + 1] != 2 || [pTable + 3] != 1) then
    [[PTBR + 2*((userSP-1)/512)] * 512 + ((userSP-1)%512)] = -1;
    [pTable + 9] = 0;
    SP = [pTable + 13];
    ireturn;
endif;

multipush(R1,R2,R3);
// call AQUIRE KERNEL LOCK
R1 = ACQUIRE_KERN_LOCK;
call ACCESS_CONTROL;

// Aquire Scheduler
R1 = ACQUIRE_SCHED_LOCK;
call ACCESS_CONTROL;
multipop(R1,R2,R3);



reset;

multipush(R1,R2,R3);
// Release Scheduler
R1 = RELEASE_LOCK;
R2 = SCHED_LOCK;
call ACCESS_CONTROL;

// calling RELEASE KERNEL LOCK
R1 = RELEASE_LOCK;
R2 = KERN_LOCK;
call ACCESS_CONTROL;



R1 = KILL_ALL;
R2 = [SYSTEM_STATUS_TABLE + 5*CORE + 1];
call PROCESS_MANAGER;


//inode table
R1 = DISK_STORE;
R2 = [SYSTEM_STATUS_TABLE + 5*CORE + 1];
R3 = 59;
R4 = 3;
call DEVICE_MANAGER;

// inode table + user table
R1 = DISK_STORE;
R2 = [SYSTEM_STATUS_TABLE + 5*CORE + 1];
R3 = 60;
R4 = 4;
call DEVICE_MANAGER;


//root file

R1 = DISK_STORE;
R2 = [SYSTEM_STATUS_TABLE + 5*CORE + 1];
R3 = 62;
R4 = 5;
call DEVICE_MANAGER;



//disk free list
R1 = DISK_STORE;
R2 = [SYSTEM_STATUS_TABLE + 5*CORE + 1];
R3 = 61;
R4 = 2;
call DEVICE_MANAGER;


// terminates all the processes except IDLE, INIT and the process calling Shutdown.
R1 = KILL_ALL;
R2 = [SYSTEM_STATUS_TABLE + 5*CORE + 1];
call PROCESS_MANAGER;

multipop(R1,R2,R3);


alias bTable R4;
alias bNo R5;
bNo = 0;
while (bNo < MAX_BUFFER) do
    bTable = BUFFER_TABLE + bNo * 4;
    
    if ([bTable + 1] == 1) then
        multipush(R1,R2,R3,R4,R5);	
        R1 = DISK_STORE;
        R2 = [SYSTEM_STATUS_TABLE + 5*CORE + 1]; //  PID
        R3 = BUFFER_BASE + bNo; // Page Number
        R4 = [bTable]; // Block Number
        call DEVICE_MANAGER;
        multipop(R1,R2,R3,R4,R5);
        
        [bTable + 1] = 0;
    endif;
    bNo = bNo + 1;
endwhile;

halt;
