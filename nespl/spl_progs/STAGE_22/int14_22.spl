alias userSP R1;
alias sysCallNo R2;
alias pTable R3;
pTable = PROCESS_TABLE + [SYSTEM_STATUS_TABLE+1]*16;
[pTable + 13]= SP;
SP = [pTable + 11] * 512  - 1 ;
PTBR = [pTable + 14];
userSP = [pTable + 13];
sysCallNo = [[PTBR + 2*((userSP-5)/512)] * 512 + ((userSP-5)%512)] ;
[pTable + 9] = sysCallNo;



// Extract the semaphore descriptor from the user stack. 
alias semId R4;
semId  = [[PTBR + 2*((userSP-4)/512)] * 512 + ((userSP-4)%512)] ;
alias ppTable R5;
ppTable = (([pTable + 11] + 1) * 512 ) + -16+2*semId;  


if(semId>7 || semId < 0 || [ppTable] != 1 ) then					//check if semid lies in valid range and if ppTable has entry for semid
    [[PTBR + 2*((userSP-1)/512)] * 512 + ((userSP-1)%512)] = -1;
    [pTable + 9] = 0;
    SP = [pTable + 13];
    ireturn;
endif;


alias sTableIndex R6;
sTableIndex = [ppTable+1];
alias sTable R7;
sTable = SEMAPHORE_TABLE + sTableIndex * 4;



if(sysCallNo == 19) then 										//  SemLock


    while([sTable] != -1 && [sTable] != [SYSTEM_STATUS_TABLE+1]) do 					// the semaphore is already locked
        [pTable + 4] = WAIT_SEMAPHORE;									//set current process to waiting
        [pTable + 5] = sTableIndex;

        multipush(R0,R1,R2,R3,R4,R5,R6,R7);								//call scheduler
        call SCHEDULER;
        multipop(R0,R1,R2,R3,R4,R5,R6,R7);
    endwhile;

    [sTable] = [SYSTEM_STATUS_TABLE+1];

endif;

if(sysCallNo == 20) then 										// SemUnLock

    if([sTable] != -1) then 										// If semaphore is locked

        if([sTable] != [SYSTEM_STATUS_TABLE+1]) then							//if current process did not lock the semaphore then store -2 
            [[PTBR + 2*((userSP-1)/512)] * 512 + ((userSP-1)%512)] = -2;
            [pTable + 9] = 0;
            SP = [pTable + 13];
            ireturn;
        endif;
        
        [sTable] = -1;											//invalidate locking pid

        alias i R8;
        i = 0;
        while(i <  16) do										//set all processes waiting for the semaphore as ready
            if (([PROCESS_TABLE +16*i+ 4] == WAIT_SEMAPHORE && [PROCESS_TABLE +16*i+ 5] == sTableIndex )) then
                [PROCESS_TABLE +16*i+ 4] = READY;
            endif;
            i=i+1;
        endwhile;
    endif;
endif;

[[PTBR + 2*((userSP-1)/512)] * 512 + ((userSP-1)%512)] = 0;
[pTable + 9] = 0;
SP = [pTable + 13];
ireturn;
