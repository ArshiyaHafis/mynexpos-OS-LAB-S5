alias functionNum R1;
alias currentPID R2;

if(functionNum == ACQUIRE_TERMINAL) then // Aquire Terminal
    while([TERMINAL_STATUS_TABLE]==1) do
        [PROCESS_TABLE +16*currentPID+ 4] = WAIT_TERMINAL; 
        multipush(R1,R2);
        call SCHEDULER;
        multipop(R1,R2);
    endwhile;
    [TERMINAL_STATUS_TABLE]=1;
    [TERMINAL_STATUS_TABLE+1] = currentPID;
endif;

if(functionNum == RELEASE_TERMINAL) then // Release Terminal
    if(currentPID !=  [TERMINAL_STATUS_TABLE+1]) then
        R0=-1;
        return;
    else 
        [TERMINAL_STATUS_TABLE]=0;
        alias i R5;
        i = 1;
        while(i <  16) do
            if (([PROCESS_TABLE +16*i+ 4] == WAIT_TERMINAL)) then
                [PROCESS_TABLE +16*i+ 4] = READY;
            endif;
            i=i+1;
        endwhile;
        R0=0;
        return;
    endif;
endif;

if(functionNum == ACQUIRE_DISK) then // Aquire Disk 
    while([DISK_STATUS_TABLE]==1) do
        [PROCESS_TABLE +16*currentPID+ 4] = WAIT_DISK; 
        multipush(R1,R2);
        call SCHEDULER;
        multipop(R1,R2);
    endwhile;
    [DISK_STATUS_TABLE]=1;
    [DISK_STATUS_TABLE+4] = currentPID;
endif;


if(functionNum == ACQUIRE_SEMAPHORE) then // Aquire Semaphore 

    alias count R3;
    alias semaphoreTableEntryAddress R4;
    alias freeSemaphore R0;
    count =0;
    freeSemaphore = -1;

    while(count <  MAX_SEM_COUNT) do 
        semaphoreTableEntryAddress = SEMAPHORE_TABLE + count * 4;

        // A free entry in the semophore table is indicated by process count 0
        if([semaphoreTableEntryAddress+1] == 0) then
            freeSemaphore = count;
            break;
        endif;
        count = count +1;
    endwhile;
    if(freeSemaphore == -1) then
        return;
    endif;

    [semaphoreTableEntryAddress] = -1; //  LOCKING_PID
    [semaphoreTableEntryAddress+1] = 1; // PROCESS_COUNT
endif;

if(functionNum == RELEASE_SEMAPHORE) then // Release Semaphore 
    alias semaphoreTableIndex R2;
    alias currentPID R3;
    alias semaphoreTableEntryAddress R4;

    semaphoreTableEntryAddress = SEMAPHORE_TABLE + semaphoreTableIndex * 4;
    if([semaphoreTableEntryAddress] == currentPID) then
        [semaphoreTableEntryAddress] = -1;
        alias i R5;
        i = 0;
        while(i <  16) do
            if (([PROCESS_TABLE +16*i+ 4] == WAIT_SEMAPHORE && [PROCESS_TABLE +16*i+ 5] == semaphoreTableIndex )) then
                [PROCESS_TABLE +16*i+ 4] = READY;
            endif;
            i=i+1;
        endwhile;
        [semaphoreTableEntryAddress+1] = [semaphoreTableEntryAddress+1] -1; //  When the count becomes 0, the semaphore is free. 
        R0 = 0;
    else 
        R0 = -1;
    endif;
endif;

if(functionNum == ACQUIRE_INODE) then

    alias inodeIndex R2;
    alias currentPID R3;
    alias fsTable R4;
    
    fsTable = FILE_STATUS_TABLE + inodeIndex*4;
    while([fsTable] != -1) do
        [PROCESS_TABLE +16*currentPID+ 4] = WAIT_FILE; 
        [PROCESS_TABLE +16*currentPID+ 5] = inodeIndex; 
        multipush(R1,R2);
        call SCHEDULER;
        multipop(R1,R2);
    endwhile;
    
    if([INODE_TABLE + inodeIndex*16 + 1] == -1) then
        R0 = -1;
        return;
    endif;
    
    [fsTable] = currentPID;
    R0 = 0;
endif;


if(functionNum ==  RELEASE_INODE) then
    alias inodeIndex R2;
    alias currentPID R3;
    alias fsTable R4;
    fsTable = FILE_STATUS_TABLE + inodeIndex*4;
    
    if([fsTable] != currentPID) then
        R0 = -1;
        return;
    endif;
    
    [fsTable] = -1;
    alias i R5;
    i = 0;
    while(i <  16) do
        if (([PROCESS_TABLE +16*i+ 4] == WAIT_FILE && [PROCESS_TABLE +16*i+ 5] == inodeIndex )) then
            [PROCESS_TABLE +16*i+ 4] = READY;
        endif;
        i=i+1;
    endwhile;
    
    R0 = 0;
endif;

return;
