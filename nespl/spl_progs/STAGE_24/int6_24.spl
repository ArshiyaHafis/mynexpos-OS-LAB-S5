alias pTable R1;
pTable = PROCESS_TABLE + ([SYSTEM_STATUS_TABLE+1]*16);
[pTable + 9] = 6;
[pTable + 13] = SP;
alias userSP R2;
userSP=SP;
SP = [pTable+ 11] * 512 - 1;
PTBR = [pTable+ 14];
alias fd R3;
alias returnAddress R4;



fd = [[PTBR + 2*((userSP-4)/512)] * 512 + ((userSP-4)%512)] ;
returnAddress = [PTBR + 2*((userSP-1)/512)] * 512 + ((userSP-1)%512) ;


if(fd == -1) then							//read input from terminal

    alias word R5;
    word = [[PTBR + 2*((userSP-3)/512)] * 512 + ((userSP-3)%512)] ;
  

    multipush(R1, R2, R3, R4, R5);
    R1 = TERMINAL_READ;
    R2 = [SYSTEM_STATUS_TABLE+1];
    R3 = word;
    call DEVICE_MANAGER;
    multipop(R1, R2, R3, R4, R5);

   
else
    if(fd<0 || fd>7) then					//invalid fd
        [returnAddress] = -1;
        [pTable + 9] = 0;
        SP = [pTable + 13] ;
        ireturn;
    endif;
    
    alias pprTable R5;								//get per process resource table entry
    pprTable = [pTable + 11]  * 512  + RESOURCE_TABLE_OFFSET + 2*fd;


    if( [pprTable] != FILE) then			//invalid ppr entry
        [returnAddress] = -1;
        [pTable + 9] = 0;
        SP = [pTable + 13] ;
        ireturn;
    endif;

    alias oftTable R6;
    alias iIndex R7;
    oftTable = OPEN_FILE_TABLE + [pprTable + 1] * 4;
    iIndex = [oftTable];
    
    multipush(R1,R2,R3,R4,R5,R6,R7);				//acuire inode
    R1 = ACQUIRE_INODE;
    R2 = iIndex;
    R3 = [SYSTEM_STATUS_TABLE+1];
    call RESOURCE_MANAGER;
    multipop(R1,R2,R3,R4,R5,R6,R7);

    if(R0 == -1) then
        [returnAddress] = -1;
        [pTable + 9] = 0;
        SP = [pTable + 13];
        ireturn;
    endif;

    alias logicalAddressOfMemoryBuffer R8;
    logicalAddressOfMemoryBuffer = [([PTBR + 2* ((userSP - 3) / 512)] * 512) + ((userSP - 3) % 512)] ;
    if(iIndex == INODE_ROOT) then
        if([oftTable+2] == 480) then				//end of root file
        
            multipush(R1,R2,R3,R4,R5,R6,R7,R8,R9);
            R1 = RELEASE_INODE;
            R2 = iIndex;
            R3 = [SYSTEM_STATUS_TABLE+1];
            call RESOURCE_MANAGER;
            multipop(R1,R2,R3,R4,R5,R6,R7,R8,R9);

            [returnAddress] = -2;
            [pTable + 9] = 0;
            SP = [pTable + 13] ;
            ireturn;

        endif;
		//no need to put in buffer as its always available in memory
        alias physicalAddressOfMemoryBuffer R9;
        physicalAddressOfMemoryBuffer = [PTBR + 2 * (logicalAddressOfMemoryBuffer/512)] * 512 + (logicalAddressOfMemoryBuffer%512);
        [physicalAddressOfMemoryBuffer] = [ROOT_FILE + [oftTable+2]];   
        [oftTable+2] = [oftTable+2] + 1;    					//read from lseek

    else
        if([oftTable+2] == [INODE_TABLE + iIndex * 16 + 2]) then		//end of file
            multipush(R1,R2,R3,R4,R5,R6,R7,R8,R9);	
            R1 = RELEASE_INODE;
            R2 = iIndex;
            R3 = [SYSTEM_STATUS_TABLE+1];
            call RESOURCE_MANAGER;
            multipop(R1,R2,R3,R4,R5,R6,R7,R8,R9);

            [returnAddress] = -2;
            [pTable + 9] = 0;
            SP = [pTable + 13] ;
            ireturn;

        endif;
	
	//find disk block number and bring block from file buffer
        multipush(R1,R2,R3,R4,R5,R6,R7,R8);
        R1 = BUFFERED_READ;
        R2 = [INODE_TABLE + iIndex*16 + 8 + [oftTable+2]/512];
        R3 = [oftTable+2]%512;
        R4 = logicalAddressOfMemoryBuffer;
        call FILE_MANAGER;
        multipop(R1,R2,R3,R4,R5,R6,R7,R8);


        [oftTable+2] = [oftTable+2] + 1;


    endif;


    multipush(R1,R2,R3,R4,R5,R6,R7,R8);
    R1 = RELEASE_INODE;
    R2 = iIndex;
    R3 = [SYSTEM_STATUS_TABLE+1];
    call RESOURCE_MANAGER;
    multipop(R1,R2,R3,R4,R5,R6,R7,R8);




endif;


[returnAddress] = 0;
[pTable + 9] = 0;
SP = [pTable + 13] ;
ireturn;
