alias functionNum R1;


if(functionNum == OPEN) then
    alias fileName R2;
    alias iIndex R3;
    alias iTable R4;
    alias i R5;

 
    iIndex = -1;
    i = 0;
    
    
    while(i < MAX_FILE_NUM) do 						//find inode entry of file to open
        iTable =  INODE_TABLE + i * 16 ; 
        if( [iTable+1]== fileName) then
            iIndex = i;
            break;
        endif;
        i = i + 1;
    endwhile;
    
    
    if(iIndex == -1) then					//no file 
        R0 = -1;
        return;
    endif;

    
    multipush(R1,R2,R3,R4);						//acquire inode - lock inode
    R1 = ACQUIRE_INODE;
    R2 = iIndex;
    R3 = [SYSTEM_STATUS_TABLE+1];
    call MOD_0;
    multipop(R1,R2,R3,R4);


    if(R0 == -1) then
        return;
    endif;
    
    if([iTable] == EXEC) then						//invalid file - exec
        multipush(R1,R2,R3,R4);
        R1 = RELEASE_INODE;
        R2 = iIndex;
        R3 = [SYSTEM_STATUS_TABLE+1];
        call MOD_0;
        multipop(R1,R2,R3,R4);
        R0 = -1;
        return;
    endif;



    alias oftEntry R6;
    oftEntry = -1;
    i = 0;
    

    while(i < MAX_OPENFILE_NUM) do				//find free entry in open file table
        if([OPEN_FILE_TABLE + i * 4] == -1) then
            oftEntry = OPEN_FILE_TABLE + i * 4;
            break;
        endif;
        i = i + 1;
    endwhile;

    if(oftEntry == -1) then						//if no free entry return -1
    
        multipush(R1,R2,R3,R4);
        R1 = RELEASE_INODE;
        R2 = iIndex;
        R3 = [SYSTEM_STATUS_TABLE+1];
        call MOD_0;
        multipop(R1,R2,R3,R4);
        
        R0 = -2;
        return;
    endif;


    if(fileName == "root") then						//if file is root 
        [oftEntry] = INODE_ROOT;
    else
        								//fill in oft entry
        [oftEntry] = iIndex;

        
        if([FILE_STATUS_TABLE + 4*iIndex + 1] == -1) then		//fill in file status table entry corresponding to inode table entry
			[FILE_STATUS_TABLE + 4*iIndex + 1] = 1;
		else
			[FILE_STATUS_TABLE + 4*iIndex + 1] = [FILE_STATUS_TABLE + 4*iIndex + 1] + 1;
		endif; 
    endif;

    [oftEntry + 1] = 1; 			// currently used by only one process
    [oftEntry + 2] = 0; 			// lseek set to beginning of file


    multipush(R1,R2,R3,R4,R5,R6);					//release inode
    R1 = RELEASE_INODE;
    R2 = iIndex;
    R3 = [SYSTEM_STATUS_TABLE+1];
    call RESOURCE_MANAGER;
    multipop(R1,R2,R3,R4,R5,R6);

    R0 = i;
endif;


if(functionNum == CLOSE ) then
    alias fd R2;


    alias oftEntry R3;
    alias iIndex R4;
    oftEntry = OPEN_FILE_TABLE + fd * 4;

    iIndex = [oftEntry];

    [oftEntry + 1] = [oftEntry + 1] - 1;

    if([oftEntry + 1] == 0) then
        [oftEntry] = -1;
        [oftEntry + 1] = -1;
        [oftEntry + 2] = -1;
        [oftEntry + 3] = -1;

        if([INODE_TABLE + iIndex*16] != ROOT) then
            [FILE_STATUS_TABLE + 4*iIndex + 1] = [FILE_STATUS_TABLE + 4*iIndex + 1] - 1;
        endif;
        if([FILE_STATUS_TABLE + 4*iIndex + 1] == 0) then
            [FILE_STATUS_TABLE + 4*iIndex + 1] = -1;
        endif;


    endif;
    
    

endif;

if (functionNum ==  BUFFERED_READ) then

    alias bNo R2;
    alias offset R3;
    alias memoryAddress R4;

    alias bfNo R5;
    bfNo = bNo % 4;




    multipush(R1,R2,R3,R4,R5);
    R1 = ACQUIRE_BUFFER;
    R2 = bfNo;
    R3 = [SYSTEM_STATUS_TABLE+1];
    call RESOURCE_MANAGER;
    multipop(R1,R2,R3,R4,R5);

    alias bTable R6;
    bTable = BUFFER_TABLE + bfNo * 4;


    if([bTable] != bNo) then			//check if buffer is free
    
        if([bTable + 1] == 1) then		//check if data in buffer is modified
        

            multipush(R1,R2,R3,R4,R5,R6);
            
            R1 = DISK_STORE;			//save the modified data to disk
            R2 = [SYSTEM_STATUS_TABLE+1]; 
            R3 = BUFFER_BASE + bfNo; 
            R4 = [bTable]; 
            call DEVICE_MANAGER;
            multipop(R1,R2,R3,R4,R5,R6);


            [bTable + 1] = 0;		//switch to clean

        endif;


        multipush(R1,R2,R3,R4,R5,R6);			//load current data to clean buffer
        R1 = DISK_LOAD;
        R4 = bNo; 
        R2 = [SYSTEM_STATUS_TABLE+1]; 
        R3 = BUFFER_BASE + bfNo; 
        call DEVICE_MANAGER;
        multipop(R1,R2,R3,R4,R5,R6);



        [bTable] = bNo;
    endif;


    [[[PROCESS_TABLE + [SYSTEM_STATUS_TABLE+1]*16 + 14] + 2 * (memoryAddress/512)] * 512 + (memoryAddress%512)] = [(BUFFER_BASE + bfNo)*512 + offset];



    multipush(R1,R2,R3,R4,R5,R6);		
    R1 = RELEASE_BUFFER;
    R2 = bfNo; 
    R3 = [SYSTEM_STATUS_TABLE+1]; 
    call RESOURCE_MANAGER;
    multipop(R1,R2,R3,R4,R5,R6);

endif;

return;
