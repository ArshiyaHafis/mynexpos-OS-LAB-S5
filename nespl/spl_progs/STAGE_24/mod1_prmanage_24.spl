alias functionNum R1;
alias currentPID R2;


if(functionNum == 1) then 				//get pcb entry

    alias pID R0; 
    alias i R3;
    alias state R4;
    pID =-1;
    i = 0;
    while(i < MAX_PROC_NUM)do
        state = [PROCESS_TABLE + i * 16 + 4];
        if(state == TERMINATED) then
            alias pTable R5;
            pTable = PROCESS_TABLE + i * 16;
            [pTable + 1] = i;
			[pTable + 4] = ALLOCATED;
			[pTable + 14] = PAGE_TABLE_BASE + (i * 20);
			[pTable + 15] = 10;
            pID = i;
            break;
        endif;
        i = i+1;
    endwhile;
endif;

if(functionNum == 2) then						//free user area page
    alias i R4;
    alias pTable R6;
    alias pprTable R7;
    i  = 0;
    pTable = PROCESS_TABLE + (currentPID*16);
    
    while(i < MAX_PROC_NUM) do 
        pprTable = (([pTable + 11] + 1) * 512 ) + (2*i) - 16;
        if([pprTable] == SEMAPHORE) then
            multipush(R1, R2, R3, R4, R5, R6, R7);
            R1 = RELEASE_SEMAPHORE;
            R3 = currentPID;
            R2 = [pprTable + 1];
            call RESOURCE_MANAGER;
            multipop(R1, R2, R3, R4, R5, R6, R7);
        endif;
        
        if([pprTable] == FILE) then
            multipush(R1, R2, R3, R4, R5, R6, R7);
            R1 = CLOSE;
            R2 = [pprTable + 1];
            call FILE_MANAGER;
            multipop(R1, R2, R3, R4, R5, R6, R7);
        endif;
        i = i + 1;
    endwhile;

    alias userAreaPageNum R3;
    userAreaPageNum = [PROCESS_TABLE + currentPID * 16 + 11];
    multipush(R1, R2);
    R1 = RELEASE_PAGE; 
    R2 = userAreaPageNum;
    call MEMORY_MANAGER; // Memory Manager 
    multipop(R1, R2);

endif;

if(functionNum == 3) then 									// exit process
    multipush( R1, R2);
    R1 = 4;
    R2 = currentPID;
    call MOD_1;
    multipop(R1, R2);


    multipush( R1, R2);
    R1 = 2;
    R2 = currentPID;
    call PROCESS_MANAGER;
    multipop( R1, R2);

    [PROCESS_TABLE + currentPID * 16 + 4] = TERMINATED;
    if([PROCESS_TABLE+currentPID*16+9] != 9) then
        alias i R5;
        alias currentPA R4;

        i = 0;
        while(i < MAX_PROC_NUM) do
            currentPA = PROCESS_TABLE + i * 16;
            if([currentPA + 4] == WAIT_PROCESS && [currentPA + 5] == currentPID) then
                [currentPA + 4] = READY;
                [currentPA + 5] = -1;
            endif;
            if([currentPA + 2] == currentPID) then
                [currentPA + 2] = -1;
            endif;
            i = i + 1;
        endwhile;

        

    endif;
    return;
endif;

if(functionNum == FREE_PAGE_TABLE) then
    alias ptbr R3;
    ptbr = [PROCESS_TABLE + currentPID * 16 + 14];
    [ptbr + 0] = -1;
    [ptbr + 1] = "0000";
    [ptbr + 2] = -1;
    [ptbr + 3] = "0000";
    
    alias ptlr R4;
    alias i R5;
    ptlr = [PROCESS_TABLE + currentPID * 16 + 15];
    i = 4;
    while(i < ptlr) do
        alias page R6;
        page = [ptbr + i * 2];
        if(page != -1) then
            multipush(R1, R2, R3, R4, R5, R6);
            R1 = RELEASE_PAGE;
            R2 = page;
            call MEMORY_MANAGER;
            multipop(R1, R2, R3, R4, R5, R6);
            [ptbr + i * 2] = -1;
            [ptbr + i * 2 + 1] = "0000";
        endif;
        i = i + 1;
    endwhile;

    alias disk_entry R3;
    disk_entry = [DISK_MAP_TABLE + currentPID * 10 ];
    i = 2;
    while(i < 10) do
        alias bNo R4;
        bNo = [disk_entry + i];
        if(bNo != -1) then
            multipush( R1, R2, R3, R4, R5);
            R1 = RELEASE_BLOCK;
            R3 = currentPID;
            R2 = bNo;
            call MEMORY_MANAGER;
            multipop( R1, R2, R3, R4, R5);
            // Invalidate all the entries of the disk map table.
            [disk_entry + i] = -1;
        endif;
        i = i + 1;
    endwhile;
    
endif;

    




return;
