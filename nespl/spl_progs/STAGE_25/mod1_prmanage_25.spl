//PROCESS_MANAGER MODULE

alias functionNum R1;
alias currentPID R2;



//GET PCB ENTRY
if(functionNum == 1) then 				//get pcb entry

    alias pID R0; 
    alias i R3;
    alias state R4;
    pID =-1;
    i = 0;
    while(i < MAX_PROC_NUM)do
        state = [PROCESS_TABLE + i * 16 + 4];
        if(state == TERMINATED) then
            alias pTable R5;
            pTable = PROCESS_TABLE + i * 16;
            [pTable + 1] = i;
			[pTable + 4] = ALLOCATED;
			[pTable + 14] = PAGE_TABLE_BASE + (i * 20);
			[pTable + 15] = 10;
            pID = i;
            break;
        endif;
        i = i+1;
    endwhile;
endif;

//FREE USER AREA PAGE 
if (functionNum == 2)then

    multipush(R1,R2,R3);

    alias resourceTableBase R3;
    resourceTableBase = [PROCESS_TABLE + (currentPID * 16) + 11]*512 + 496;
    
    alias i R4;
    i = 0;
    while(i<8)do
        if ( [resourceTableBase + 2*i] == SEMAPHORE )then
            multipush(R1,R2,R3,R4);
            R1 = 7;
            R2 = [resourceTableBase + 2*i + 1];
            R3 = [SYSTEM_STATUS_TABLE+1];
            call RESOURCE_MANAGER;
            multipop(R1,R2,R3,R4);
        endif;
        if ( [resourceTableBase + 2*i] == FILE )then
            multipush(R1,R2,R3,R4);
            R1 = 4;
            R2 = [resourceTableBase + 2*i + 1];
            call FILE_MANAGER;
            multipop(R1,R2,R3,R4);
        endif;
        [resourceTableBase + 2*i] = -1;
        i = i + 1;
    endwhile;

    R1 = 2;
    R2 = [PROCESS_TABLE + (currentPID * 16) + 11];
    call MEMORY_MANAGER;
    multipop(R1,R2,R3);

    return;
endif;



if(functionNum == 3) then 									// exit process
    multipush( R1, R2);
    R1 = 4;
    R2 = currentPID;
    call MOD_1;
    multipop(R1, R2);


    multipush( R1, R2);
    R1 = 2;
    R2 = currentPID;
    call PROCESS_MANAGER;
    multipop( R1, R2);

    [PROCESS_TABLE + currentPID * 16 + 4] = TERMINATED;
    if([PROCESS_TABLE+currentPID*16+9] != 9) then
        alias i R5;
        alias currentPA R4;

        i = 0;
        while(i < MAX_PROC_NUM) do
            currentPA = PROCESS_TABLE + i * 16;
            if([currentPA + 4] == WAIT_PROCESS && [currentPA + 5] == currentPID) then
                [currentPA + 4] = READY;
            endif;
            if([currentPA + 2] == currentPID) then
                [currentPA + 2] = -1;
            endif;
            i = i + 1;
        endwhile;

        

    endif;
    return;
endif;




if(functionNum == FREE_PAGE_TABLE) then
    alias ptbr R3;
    ptbr = [PROCESS_TABLE + currentPID * 16 + 14];
    [ptbr + 0] = -1;
    [ptbr + 1] = "0000";
    [ptbr + 2] = -1;
    [ptbr + 3] = "0000";
    
    alias ptlr R4;
    alias i R5;
    ptlr = [PROCESS_TABLE + currentPID * 16 + 15];
    i = 4;
    while(i < ptlr) do
        alias page R6;
        page = [ptbr + i * 2];
        if(page != -1) then
            multipush(R1, R2, R3, R4, R5, R6);
            R1 = RELEASE_PAGE;
            R2 = page;
            call MEMORY_MANAGER;
            multipop(R1, R2, R3, R4, R5, R6);
            [ptbr + i * 2] = -1;
            [ptbr + i * 2 + 1] = "0000";
        endif;
        i = i + 1;
    endwhile;

    alias disk_entry R3;
    disk_entry = [DISK_MAP_TABLE + currentPID * 10 ];
    i = 2;
    while(i < 10) do
        alias bNo R4;
        bNo = [disk_entry + i];
        if(bNo != -1) then
            multipush( R1, R2, R3, R4, R5);
            R1 = RELEASE_BLOCK;
            R3 = currentPID;
            R2 = bNo;
            call MEMORY_MANAGER;
            multipop( R1, R2, R3, R4, R5);
            // Invalidate all the entries of the disk map table.
            [disk_entry + i] = -1;
        endif;
        i = i + 1;
    endwhile;
    
endif;

//KILL ALL 
if (functionNum == 5)then

    alias index R4;							//acquire lock on all files in inode table
    index = 0 ;
    while (index < MAX_FILE_NUM )do
        if( [INODE_TABLE + 16*index + 1] != -1 )then
            multipush(R1,R2,R3,R4);
            R3 = currentPID;
            R2 = index;
            R1 = 4;
            call RESOURCE_MANAGER;
            multipop(R1,R2,R3,R4);
        endif;
        index = index + 1;
    endwhile;


    index = 2;
    while ( index < MAX_PROC_NUM -1 )do
        if ( index != currentPID && [PROCESS_TABLE + index*16 + 4]!=TERMINATED )then		//call exit process on all processes except itself
            multipush(R1,R2,R3,R4);
            R1 = 3;
            R2 = index;
            call PROCESS_MANAGER;
            multipop(R1,R2,R3,R4);
        endif;
        index = index + 1;
    endwhile;


    index = 0;
    while ( index < MAX_FILE_NUM) do							//release lock on inode
        if ( [INODE_TABLE + index * 16 + 1 ]!= -1 )then
            multipush(R1,R2,R3,R4);
            R1 = 5;
            R3 = currentPID;
            R2 = index;
            call RESOURCE_MANAGER;
            multipop(R1,R2,R3,R4);
        endif;
        index =  index  + 1;
    endwhile;
    
    return;
endif;

return;
